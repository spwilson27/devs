# MCP and AI Development Design: Project 'devs'

## 1. AI Development Philosophy & Glass-Box Architecture

The 'devs' system is predicated on the **Glass-Box Architecture** principle. Unlike traditional "black-box" AI systems that ingest a prompt and emit a final result, 'devs' exposes every internal state transition, reasoning step, and tool interaction as a first-class citizen of the development lifecycle. This philosophy ensures that the system is authoritative, unambiguous, and entirely auditable by both humans and supervisor agents.

### 1.1 The Five Pillars of Glass-Box Development
To achieve professional-grade reliability and architectural integrity, the system adheres to five non-negotiable pillars:

1.  **Research-First Methodology [3_MCP-REQ-GOAL-001]**: No implementation occurs until the problem space, technology landscape, and competitive analysis are finalized and approved. This prevents architectural drift.
2.  **Architecture-Driven Development (ADD) [3_MCP-REQ-GOAL-002]**: Every project must have a validated PRD and TAS before implementation begins. Implementation agents are strictly bound by these blueprints.
3.  **Strict TDD (Test-Driven Development) Loop [3_MCP-REQ-GOAL-005]**: A mandatory "Red-Green-Refactor" cycle where tests are the primary source of truth for requirement fulfillment.
4.  **Agentic Observability & Traceability [3_MCP-TAS-001]**: Every decision, tool call, and reasoning step is logged, queryable, and streamable in real-time.
5.  **MCP-Native Integration [3_MCP-TAS-003]**: Both the orchestrator and the generated code utilize the Model Context Protocol to provide standardized interfaces for introspection, debugging, and profiling.

### 1.2 The Structured Agent-Orchestrator Protocol (SAOP)
**[3_MCP-TAS-035]** All interactions between the Agent Suite and the Orchestration Layer MUST follow the SAOP specification to ensure deterministic execution and transparent reasoning.

#### 1.2.1 Turn Envelope Schema & Execution Logic [3_MCP-TAS-070]
Every interaction turn is encapsulated in a strictly-typed JSON structure. The orchestrator MUST validate the schema before execution.

```typescript
interface SAOP_Envelope {
  header: {
    version: "1.0.0";
    agent_id: "researcher" | "architect" | "developer" | "reviewer";
    task_id: string; // Correlation ID to the SQLite tasks table
    thread_id: string; // For tracing multi-turn reasoning chains
    timestamp: string; // ISO 8601 UTC
  };
  payload: {
    analysis: {
      observation_reflection: string; // Critical analysis of previous tool outputs
      state_assessment: string; // Evaluation of progress against the Requirement DAG
      reasoning_chain: string; // Detailed internal monologue (Chain-of-Thought)
    };
    intent: {
      current_strategy: string; // High-level plan for the current turn
      predicted_outcome: string; // Expected effect on the system/codebase
      requirement_id?: string; // Optional: Link to a specific REQ-ID being addressed
    };
    commands: Array<{
      call_id: string; // Unique ID for tool invocation tracing
      tool: string; // MCP tool name
      arguments: Record<string, any>; // Tool-specific payload
    }>;
  };
  telemetry: {
    confidence: number; // 0.0 to 1.0 certainty score
    estimated_complexity: "low" | "medium" | "high";
    token_usage_hint?: number; // Estimated cost of the turn
  };
}
```

#### 1.2.2 SAOP Edge Cases & Error Handling
- **Malformed Response [3_MCP-TAS-071]**: If the agent returns invalid JSON or fails the schema check, the orchestrator MUST trigger a "Formatting Correction" turn (max 2 retries) before escalating to the user.
- **Partial Completions [3_MCP-TAS-072]**: In cases where the LLM hits a token limit mid-envelope, the orchestrator MUST implement a "Resume Protocol" that prompts the agent to complete the JSON payload starting from the last valid token.
- **Tool Timeout [3_MCP-TAS-073]**: If an MCP tool exceeds the 300s timeout, the observation returned to the agent MUST include a `TIMEOUT_EXCEEDED` status, forcing the agent to reassess its strategy.

### 1.3 The "Agent-Ready" Code Standard
**[3_MCP-MCP-001]** Projects generated by 'devs' are optimized for agentic interaction, ensuring they are "Transparent by Design."

- **[3_MCP-REQ-MET-007] Documentation Density (AOD)**: Every significant module MUST include an Agent-Oriented Documentation (`.agent.md`) file defining intent, architecture, and agentic hooks.
- **Requirement-Tagged Logic [3_MCP-REQ-MCP-001]**: Source code blocks and test cases SHOULD include comments or metadata linking them back to specific `REQ-ID`s from the PRD.
- **Standardized Introspection [3_MCP-TAS-074]**: Implementation MUST include "Introspection Points"â€”predetermined locations in the code (e.g., custom events, state snapshots) that the internal MCP server can query.

### 1.4 Glass-Box Observability Infrastructure
**[3_MCP-MCP-002]** The system implements a "Flight Recorder" pattern via a local SQLite database (`.devs/state.sqlite`).

#### 1.4.1 Persistent Traceability & Audit Trails
- **Reasoning Persistence [3_MCP-TAS-075]**: The `payload.analysis.reasoning_chain` is never discarded. It is stored as a blob in the `agent_logs` table, allowing for post-hoc analysis of "hallucination triggers."
- **Immutable Observations [3_MCP-TAS-076]**: Tool outputs (observations) are captured in their raw, unsummarized form. This prevents agents from misinterpreting failed test results during the reflection phase.
- **[3_MCP-TAS-038] Real-time Trace Streaming**: The orchestrator MUST support a websocket or SSE (Server-Sent Events) stream of the SAOP envelopes, enabling the VSCode Extension to display the agent's "Thought Stream" with minimal latency.

#### 1.4.2 Deterministic State Recovery [3_MCP-REQ-REL-003]
- **ACID State Transitions [3_MCP-REQ-REL-004]**: Every state change (task start, tool execution, commit) is wrapped in a SQLite transaction.
- **[3_MCP-TAS-039] Git-DB Correlation**: Every successful task completion maps to a Git Commit. The `tasks` table stores the `HEAD` hash, enabling a "Hard Rewind" that restores both the filesystem and the database to a consistent historical state.

### 1.5 Safety, Entropy, and Human-in-the-Loop (HITL)
The Glass-Box architecture is the primary mechanism for preventing autonomous "runaway" scenarios.

- **[3_MCP-TAS-019] Entropy Detection**: By comparing the hashes of the last 3 SAOP observation payloads, the system identifies looping behavior. If detected, the Glass-Box forces an "Architectural Review" turn where the agent must summarize its failures before proceeding.
- **Gated Autonomy [3_MCP-REQ-UI-001]**: Explicit checkpoints (e.g., TAS approval) are enforced by the orchestrator. The state machine "Freezes" and waits for a `RESUME` signal from the `OrchestratorServer`.
- **[3_MCP-TAS-023] Secret Masking**: The `SecretMasker` is a mandatory filter in the observation pipeline, ensuring that sensitive data (API keys, PII) is redacted before being stored in the Glass-Box or returned to the LLM.

### 1.6 Unknowns & Implementation Risks
- **[3_MCP-RISK-101] Reasoning Log Volume**: For projects with 200+ tasks, the `agent_logs` table may exceed several gigabytes. We need an archival strategy that maintains the "Traceability" index while offloading old blobs.
- **[3_MCP-RISK-102] Schema Evolution**: If the SAOP schema updates mid-project, older logs may become incompatible. A versioned migration strategy for `.devs/state.sqlite` is required.
- **[3_MCP-UNKNOWN-101]**: How should the system handle multi-agent collaboration within the same Glass-Box? Will multiple agents write to the same `agent_logs` thread, or should each have a dedicated `agent_id` partition?

## 2. Model Context Protocol (MCP) Infrastructure

The system relies on three distinct MCP server categories to facilitate autonomous development. These servers act as the "eyes and hands" of the agents, providing standardized access to the orchestrator's state, the execution environment, and the generated application's internals.

### 2.1 OrchestratorServer (System Control & Observability)
**[3_MCP-TAS-036]** The OrchestratorServer resides at the root of the `devs` engine. It exposes the internal state machine, memory stores, and human-in-the-loop (HITL) coordination mechanisms. It is the primary interface for the VSCode Extension and CLI.

#### 2.1.1 Core Toolset [3_MCP-TAS-077]
| Tool | Parameters | Return Type | Description |
| :--- | :--- | :--- | :--- |
| `get_project_context` | `{ project_id: string, include_docs?: boolean }` | `ProjectContext` | Returns the active PRD, TAS, and a summary of requirement fulfillment. |
| `search_memory` | `{ query: string, limit?: number, type?: MemoryType }` | `MemoryResult[]` | Performs semantic search across the LanceDB vector store (Long-term Memory). |
| `manage_hitl_gate` | `{ action: "approve" \| "reject" \| "list", gate_id?: string, feedback?: string }` | `GateStatus` | Handles manual sign-offs for PRDs, TAS, and Epic transitions. |
| `get_task_trace` | `{ task_id: string, format?: "json" \| "markdown" }` | `SAOP_Trace` | Retrieves the full reasoning chain and tool log for a completed or active task. |
| `inject_directive` | `{ task_id: string, text: string, priority: number }` | `void` | Inserts a high-priority constraint into the agent's short-term memory (Short-term Memory). |
| `rewind_to_checkpoint` | `{ checkpoint_id: string, strategy: "hard" \| "soft" }` | `RewindStatus` | Reverts the state machine and filesystem to a previous verified commit. |

#### 2.1.2 Data Models (Orchestrator) [3_MCP-TAS-078]
```typescript
interface ProjectContext {
  requirements: Array<{ id: string; status: "pending" | "met" | "failed"; doc_link: string }>;
  active_epic: { id: string; title: string; progress: number };
  constraints: string[]; // Project-wide "Long-term Memory" rules
}

interface SAOP_Trace {
  turns: SAOP_Envelope[];
  total_tokens: number;
  duration_ms: number;
}
```

### 2.2 SandboxServer (Isolated Execution Environment)
**[3_MCP-TAS-037]** Injected into the ephemeral Docker or WebContainer environment. It provides a secure, monitored interface for the Developer Agent to manipulate code and verify implementation.

#### 2.2.1 Core Toolset [3_MCP-TAS-079]
| Tool | Parameters | Return Type | Description |
| :--- | :--- | :--- | :--- |
| `filesystem_operation` | `{ action: "read" \| "write" \| "list" \| "move", path: string, content?: string }` | `FSResult` | Atomic file operations with path validation and size limits (max 500KB per read). |
| `apply_surgical_edits` | `{ path: string, edits: Array<{ old: string, new: string }> }` | `EditResult` | Replaces specific text blocks to prevent full-file overwrite corruption. |
| `search_codebase` | `{ pattern: string, include_globs?: string[], case_sensitive?: boolean }` | `SearchResult[]` | Fast, grep-like search across the project source and tests. |
| `run_shell_monitored` | `{ command: string, env?: Record<string, string>, timeout?: number }` | `ShellOutput` | Executes shell commands with real-time `SecretMasker` and resource capping. |
| `dependency_manager` | `{ action: "install" \| "remove" \| "audit", packages: string[] }` | `DepResult` | Manages project dependencies via allowed-list package managers (npm, pip, etc.). |
| `git_controller` | `{ action: "commit" \| "diff" \| "status" \| "stash", message?: string }` | `GitOutput` | Ensures atomic versioning and audit trails for every task implementation. |

#### 2.2.2 Security & Isolation Policies
- **Path Sanitization [3_MCP-REQ-SEC-001]**: All paths are resolved against the project root. Attempts to access `..` or system paths (e.g., `/etc`) result in an immediate `ACCESS_DENIED` observation.
- **Resource Quotas [3_MCP-REQ-SEC-002]**: `run_shell_monitored` kills processes exceeding 4GB RSS or 100% CPU for > 10 seconds.
- **Secret Redaction [3_MCP-TAS-023]**: Every byte emitted to `stdout` is piped through the `SecretMasker` before being returned to the agent.

### 2.3 ProjectServer (Agentic Debugging & Introspection)
**[3_MCP-TAS-043]** Every project generated by `devs` MUST include an internal MCP server at `<root>/mcp-server`. This enables the agent to interact with its own creation as an expert debugger.

#### 2.3.1 Core Toolset [3_MCP-TAS-080]
| Tool | Parameters | Return Type | Description |
| :--- | :--- | :--- | :--- |
| `inspect_state` | `{ path: string, depth?: number }` | `JSON` | Reads internal memory, cache values, or singleton states of the running application. |
| `run_test_task` | `{ test_path: string, reporter: "json" \| "tap" }` | `StructuredTestReport` | Executes specific tests and returns machine-readable failure analysis (stack traces, diffs). |
| `db_bridge` | `{ action: "query" \| "schema" \| "seed", payload: string }` | `DBResult` | Direct access to the application's internal database for data-integrity verification. |
| `capture_trace` | `{ duration_ms: number, type: "cpu" \| "heap" \| "network" }` | `ProfileData` | Generates a performance snapshot to identify bottlenecks during the "Refactor" phase. |
| `get_logs` | `{ level: string, limit: number, follow?: boolean }` | `LogEntry[]` | Streams structured application logs for runtime behavior analysis. |

#### 2.3.2 Implementation Requirements (AOD)
- **Agent-Oriented Documentation (AOD) [3_MCP-REQ-MET-008]**: The ProjectServer MUST register all tools in the `.agent/index.agent.md` manifest so agents know which "Introspection Points" are available.
- **Lifecycle Sync [3_MCP-TAS-081]**: The ProjectServer MUST automatically start when the `DeveloperAgent` runs the application's "Dev Mode" within the sandbox.

### 2.4 MCP Discovery & Tool Lifecycle
**[3_MCP-TAS-063]** Agents discover available tools through the MCP `list_tools` capability, which is filtered by the orchestrator based on the current Phase.

1.  **Discovery Phase**: Researcher agents only see Orchestrator tools and web-search tools.
2.  **Implementation Phase**: Developer agents see Sandbox and ProjectServer tools.
3.  **Verification Phase**: Reviewer agents see all tools, with higher-privilege access to the `git_controller` for reverts.

### 2.5 Technical Risks & Unknowns
- **[3_MCP-RISK-201] Tool Hallucination**: Agents may attempt to call non-existent tools or pass invalid parameters. *Mitigation*: Strict JSON schema validation and automated "Help" prompts on failure.
- **[3_MCP-RISK-202] State Pollution**: The ProjectServer might modify the app's state during inspection (e.g., triggering a side effect). *Mitigation*: Preference for read-only tools and explicit `ROLLBACK` support in `db_bridge`.
- **[3_MCP-UNKNOWN-201]**: How should the system handle MCP tool execution in a multi-container environment (e.g., a microservices project)? Will each service have its own ProjectServer?

## 3. Agentic Development Loops

Development is driven by a deterministic **Plan-Act-Verify** cycle, implemented as a LangGraph state machine. This loop ensures that no code is committed without empirical proof of correctness and adherence to architectural standards.

### 3.1 The LangGraph State Machine (Implementation Engine)
**[3_MCP-TAS-064]** The Implementation Phase is orchestrated as a cyclical graph where each node represents a specific agentic state or tool execution boundary.

#### 3.1.1 Node Definitions & Responsibilities
- **`PlanNode` [3_MCP-TAS-082]**: The Developer Agent ingests the current task description, relevant PRD/TAS sections, and Medium-term Memory (Epic context). It generates a `TaskStrategy` object.
- **`TestNode` [3_MCP-TAS-083] (Red Phase)**: The agent writes a unit or integration test that exercises the target requirement.
- **`CodeNode` [3_MCP-TAS-084] (Green Phase)**: The agent modifies the application source code to satisfy the failing test.
- **`RefactorNode` [3_MCP-TAS-085]**: The agent performs code cleanup and ensures compliance with project-wide quality standards (linting, types).
- **`ReviewNode` [3_MCP-TAS-086] (Independent Validation)**: A separate Reviewer Agent instance validates the work, checking for TAS violations and regression failures.
- **`CommitNode` [3_MCP-TAS-087]**: Upon successful review, the state machine triggers an atomic Git commit and updates the SQLite task status.

#### 3.1.2 The Binary Gate Protocol [3_MCP-TAS-041]
Transition between nodes is governed by strict exit-code gates within the sandbox.

| Gate | Target Node | Command | Required Exit Code | Protocol Requirement |
| :--- | :--- | :--- | :--- | :--- |
| **RED** | `CodeNode` | `npm test <test_file>` | `!= 0` | Agent must identify the failing assertion in its reflection. |
| **GREEN** | `RefactorNode` | `npm test <test_file>` | `0` | All tests in the current file must pass. |
| **QUALITY** | `ReviewNode` | `npm run lint && tsc` | `0` | Zero warnings/errors from static analysis. |
| **VERIFY** | `CommitNode` | `npm test` | `0` | 100% pass rate on all Epic tests (Regression Check). |

### 3.2 Detailed Loop Execution Logic

#### 3.2.1 Turn-Based Iteration (SAOP Implementation)
Each node executes one or more SAOP turns. For example, the `CodeNode` may take up to 10 turns to reach the **GREEN** gate.
- **turn_index [3_MCP-TAS-088]**: Tracked in `agent_logs` to prevent context bloat.
- **Context Refresh [3_MCP-TAS-089]**: After 5 turns in a single node, the orchestrator re-injects the TAS and PRD summary to prevent reasoning drift.

#### 3.2.2 The Reviewer Agent's Hierarchy of Concerns [3_MCP-REQ-MET-009]
The Reviewer Agent does not just run tests; it performs a multi-dimensional audit:
1.  **Requirement Fidelity**: Does the implementation meet the *atomic requirement* defined in the Task?
2.  **TAS Compliance**: Does the code use approved patterns? (e.g., "Did the agent use an external library not in the TAS?").
3.  **Agentic Observability**: Does the module include the required `.agent.md` documentation and "Introspection Points" for the `ProjectServer`?
4.  **Security**: Does the code introduce obvious vulnerabilities (e.g., hardcoded secrets, unsafe regex)?

### 3.3 Handling Failure, Entropy, and Recovery

#### 3.3.1 Deterministic Entropy Detection [3_MCP-TAS-019]
The orchestrator maintains a sliding window of the last 3 tool observations (stdout/stderr).
- **Hash Comparison**: `hash(obs_n) == hash(obs_n-1)`. If the hash repeats, the "Entropy Counter" increments.
- **Strategy Pivot**: At a count of 3, the agent is issued a `SYSTEM_DIRECTIVE`: "You are repeating a failing strategy. You MUST abandon your current approach, reread the TAS, and propose an alternative implementation."

#### 3.3.2 Autonomous Backtracking & Rewind [3_MCP-TAS-039]
If the **VERIFY** gate (Regression Check) fails, the system triggers an automatic internal investigation:
1.  **Blame Analysis**: Identify which change broke the existing tests.
2.  **Soft Rewind**: Revert the `src/` files but keep the new `tests/` files.
3.  **Re-Implementation**: The Developer Agent must now solve the new requirement without breaking the previously passing tests.

#### 3.3.3 Flaky Test Mitigation
- **Retry Protocol [3_MCP-TAS-090]**: On a non-zero exit code during the GREEN or VERIFY phases, the orchestrator automatically retries the command twice.
- **Heuristic Analysis [3_MCP-TAS-091]**: If the test fails with different errors each time, it is flagged as `FLAKY` and the system pauses for human intervention.

### 3.4 Integration with MCP Debugging Tools

#### 3.4.1 Live Profiling during the Refactor Phase [3_MCP-MCP-009]
During the `RefactorNode`, the Reviewer Agent can optionally invoke the `capture_trace` tool via the `ProjectServer`.
- **Constraint Check**: If the memory usage or CPU execution time exceeds the thresholds defined in the TAS Security/Performance section, the task is marked `FAILED_PERFORMANCE` even if tests pass.

#### 3.4.2 State Introspection during Failures [3_MCP-TAS-092]
If the `CodeNode` cannot reach the GREEN gate after 5 turns:
1.  The agent is encouraged to use `inspect_state` (ProjectServer) to look at internal application memory.
2.  This "Expert Debugger" mode allows the agent to see *why* a variable is null or why a state transition failed, reducing hallucination-driven implementation attempts.

### 3.5 Implementation Risks & Edge Cases

#### 3.5.1 The "Shadow Requirement" Problem [3_MCP-REQ-MET-010]
- **Risk**: Agents may implement extra features not in the requirement ("Scope Creep").
- **Mitigation**: The Reviewer Agent specifically checks for code additions that have no corresponding test case or requirement mapping.

#### 3.5.2 Dependency Collision [3_MCP-TAS-093]
- **Risk**: `Task A` installs `lib-v1` and `Task B` (in parallel) installs `lib-v2`.
- **Mitigation**: The `SandboxServer`'s `dependency_manager` tool performs a `git lock` on `package.json` to ensure sequential updates and triggers a `npm audit` after every change.

#### 3.5.3 Context Window Saturation
- **Risk**: A complex task involving multiple files can exceed the 1M token limit if the loop takes too many turns.
- **Mitigation**: **[3_MCP-TAS-024]** Mandatory summarization of intermediate turns, preserving only the `Plan`, `TAS`, and the current failing `Observation`.

#### 3.5.4 Unknowns & Open Questions
- **[3_MCP-UNKNOWN-301]**: Should we allow the agent to modify the TAS mid-loop if a technical blocker is found? (Recommendation: Require a `TAS_REVISION_GATE` with user approval).
- **[3_MCP-UNKNOWN-302]**: How should the system handle long-running background processes (e.g., a database migration) that might span multiple nodes?

## 4. Debugging & Observability Strategies

The 'devs' system implements a comprehensive observability suite designed to ensure that autonomous development is transparent, performant, and safe. By treating observability as a first-class citizen, the system enables both humans and agents to diagnose failures, optimize performance, and maintain architectural integrity throughout the project lifecycle.

### 4.1 Time-Travel Debugging (The Rewind Protocol)
**[3_MCP-TAS-039]** The system provides a deterministic "Time-Travel" capability, allowing the project to be rolled back to any historical task completion state with 100% fidelity.

- **Git-SQLite Synchronization [3_MCP-TAS-094]**: Every task completion in the `ImplementationLoop` results in an atomic Git commit. The `tasks` table in `state.sqlite` records the `git_commit_hash` associated with the success state.
- **Rewind Execution Logic [3_MCP-TAS-095]**:
    1.  **Filesystem Reset**: The orchestrator executes `git checkout <hash>` for the target Task ID.
    2.  **Relational State Reset**: The `state.sqlite` database is reverted by deleting all records (logs, requirement updates, task statuses) with a timestamp greater than the target checkpoint.
    3.  **Vector Memory Pruning**: The LanceDB vector store is pruned of all semantic embeddings (decisions, preferences) generated after the rewind point to prevent "future knowledge" from polluting the agent's reasoning.
- **User Agency**: Humans can trigger a rewind via the CLI (`devs rewind --task <ID>`) or the VSCode Extension if an agent takes an undesirable architectural path.

### 4.2 Agentic Profiling & Performance Guardrails
**[3_MCP-MCP-009]** Beyond functional correctness (TDD), the system enforces performance constraints via automated agentic profiling.

- **Proactive Profiling**: During the `RefactorNode`, the **Reviewer Agent** can invoke the `capture_trace` tool via the ProjectServer to analyze the runtime characteristics of the implemented feature.
- **Guardrail Enforcement**: The profile (CPU usage, memory footprint, heap allocation) is compared against the performance constraints defined in the **TAS Security & Performance** section.
- **Automated Optimization Tasks**: If a violation is detected (e.g., O(n^2) complexity where O(log n) was expected), the Reviewer Agent MUST fail the task and generate a new "Optimization Requirement" that the Developer Agent must satisfy.
- **Deterministic Benchmarking**: Benchmarks are executed in the sandboxed environment with fixed resource limits to ensure consistent results across different host machines.

### 4.3 Real-time Trace Streaming (RTES)
**[3_MCP-TAS-038]** To achieve the "Glass-Box" vision, the orchestrator streams its internal state and reasoning in real-time.

- **Event Bus Architecture**: The orchestrator emits a stream of SAOP Envelopes via a WebSocket or SSE interface.
- **Differentiated Visualization**: The VSCode Extension consumes this stream to display:
    - **Thought Stream**: A live Markdown view of the agent's `reasoning_chain`.
    - **Action Log**: Real-time status of tool invocations (e.g., "Reading file X...", "Running test Y...").
    - **Observation Buffer**: A filtered terminal view showing masked `stdout/stderr` from the sandbox.
- **Human Intervention Points**: The stream includes `HITL_GATE_REQUIRED` events, which trigger UI prompts for approvals or directives.

### 4.4 Entropy Detection and Automated Loop Prevention
**[3_MCP-TAS-019]** The system employs deterministic entropy detection to prevent agents from wasting tokens on repetitive, failing strategies.

- **Observation Hashing**: The orchestrator computes a SHA-256 hash of the `observation` payload from the last 3 turns of a node.
- **Loop Identification**: If `hash(obs_n) == hash(obs_n-1)`, the "Entropy Counter" increments.
- **Strategy Pivot Directive**: At a count of 3, the orchestrator interrupts the agent with a mandatory `SYSTEM_PIVOT` instruction:
    - The agent MUST explicitly summarize its last 3 failed attempts.
    - The agent MUST propose a fundamentally different approach (e.g., using a different library or refactoring the test logic).
- **Escalation Pause**: If the pivot fails after 2 attempts, the system enters a `PAUSED_FOR_INTERVENTION` state and presents the failure logs to the user.

### 4.5 The "Suspended Sandbox" State
**[3_MCP-TAS-021]** For failed implementation tasks, the system preserves the execution environment for manual inspection.

- **Container Persistence**: When a task hits the entropy limit or fails a critical gate, the Docker/WebContainer sandbox is NOT destroyed. Instead, it is moved to a "Suspended" state.
- **Human Attachment**: The user can run `devs debug --task <ID>` to open a terminal session directly inside the failed sandbox, allowing for manual debugging of the code, environment, and logs.
- **Snapshot Capture**: The orchestrator captures a filesystem snapshot of the failed state, which is stored in `.devs/snapshots/` for post-mortem analysis.

### 4.6 Introspection Points and Agentic Hooks
**[3_MCP-TAS-066]** The generated project is natively "Agent-Ready" via standardized introspection interfaces.

- **Standardized Hooks**: The TAS defines "Introspection Points" for core application modules (e.g., state machines, database adapters, external service clients).
- **MCP Tooling**: The internal ProjectServer provides tools like `inspect_state` and `db_bridge` to query these hooks directly.
- **Agent-Oriented Documentation (AOD)**: Every hook MUST be documented in `.agent.md` files with clear descriptions of the data schema and intent, ensuring that Developer Agents know how to use them for debugging.

### 4.7 Root Cause Analysis (RCA) and Failure Reporting
When a task fails, the system performs an automated RCA to provide the user with actionable insights.

- **RCA Turn [3_MCP-TAS-096]**: A **Gemini 3 Pro** instance (the Reviewer) analyzes the `agent_logs` and the `Suspended Sandbox` to identify the root cause (e.g., "Dependency Conflict," "Ambiguous PRD Requirement," "Sandbox Permission Denied").
- **Failure Report [3_MCP-REQ-UI-002]**: The system generates a Markdown report containing:
    - The specific **REQ-ID** that failed.
    - A summary of the agent's "Thinking" before the failure.
    - The exact error log and a proposed manual fix or requirement clarification.
- **Learning Injection [3_MCP-TAS-097]**: The results of the RCA are stored in the **Long-term Memory** (LanceDB) to prevent similar failures in future tasks or projects.

## 5. Multi-Tiered Context & Memory Management

The 'devs' system utilizes a sophisticated, tiered memory architecture designed to solve the "Context Dilution" problem inherent in long-running autonomous development cycles. By segregating information based on its temporal relevance and architectural impact, the system ensures that agents remain focused on the immediate task while adhering to project-wide constraints and historical decisions.

### 5.1 The Tiered Memory Hierarchy [3_MCP-TAS-016] [3_MCP-TAS-017] [3_MCP-TAS-018]

| Tier | Persistence | Implementation | Scope | Key Data Points |
| :--- | :--- | :--- | :--- | :--- |
| **Short-Term (Working Set)** | Volatile (In-Context) | LLM Active Window | Active Task | Current Task ID, last 10 turns, active file buffers, terminal observations. |
| **Medium-Term (Epic Context)** | Relational | SQLite (`agent_logs`) | Active Epic | Summaries of previous tasks in the Epic, failed strategy logs, Epic-level TAS overrides. |
| **Long-Term (Project DNA)** | Vectorized | LanceDB (`memory.lancedb`) | Global Project | PRD, TAS, User Preferences, Global Constraints, Verified Architectural Patterns. |

### 5.2 Short-Term Memory: The Active Working Set
Short-term memory is the most volatile and high-resolution tier, representing the agent's immediate "Focus."

- **[3_MCP-TAS-047] Window Composition**: The orchestrator dynamically constructs the active context window for every turn, prioritizing:
    1.  **The Goal**: The current Task Description and Success Criteria (Tests).
    2.  **The Map**: A high-level summary of the TAS and the active file's structure.
    3.  **The Recent Past**: The last 5-10 SAOP envelopes (thoughts and tool results).
- **[3_MCP-TAS-048] Active File Management**: The `SandboxServer` provides tools to "Pin" specific files to the context window. Agents can read up to 5 files simultaneously; beyond that, older files are swapped out to prevent token overflow.
- **[3_MCP-TAS-051] Tool Result Retention**: Unlike reasoning traces, large tool outputs (e.g., a 200-line test log) are truncated in the context window after 2 turns, but the full raw output remains queryable via the `get_task_trace` tool.

### 5.3 Medium-Term Memory: Epic Continuity & Lessons Learned
Medium-term memory bridges the gap between individual tasks, ensuring that progress in Task 1.1 informs the execution of Task 1.2.

- **Task-to-Task Handoff [3_MCP-TAS-098]**: Upon completion of a task, the **Reviewer Agent** generates a `TaskSummary` containing:
    - The implemented interface changes and exported symbols.
    - Any new "internal knowledge" (e.g., "Module X requires the database to be seeded first").
    - A list of files modified and their impact on the dependency DAG.
- **[3_MCP-TAS-052] Strategy Blacklist**: If an agent fails a task due to a specific architectural misunderstanding (as identified by the RCA), that failure is logged as a "Lesson Learned" in SQLite. This prevents the next agent (or the same agent on retry) from attempting the same invalid strategy.

### 5.4 Long-Term Memory: The Project DNA (Vectorized)
Long-term memory is the "Source of Truth" for the entire project, persisted semantically to allow for proactive retrieval.

- **[3_MCP-TAS-011] LanceDB Implementation**:
    - **Embeddings**: Uses `text-embedding-004` (768 dimensions) for all project documents.
    - **Similarity Search**: The orchestrator performs a `cosine_similarity` search before every task to retrieve the most relevant sections of the TAS and PRD.
- **Constraint Enforcement**: Project-wide rules (e.g., "Always use TypeScript interfaces over types") are stored with a `HIGH_RELEVANCE` weight. These are injected into *every* prompt to ensure stylistic and architectural consistency.
- **Decision Log Indexing**: Every architectural decision made during Phase 2 (Design) is vectorized, allowing the Developer Agent to ask "Why was X chosen over Y?" during implementation.

### 5.5 Context Pruning, Summarization, and Refresh [3_MCP-TAS-024] [3_MCP-REQ-SYS-001]
To manage the 1M token context window of Gemini 3 Pro efficiently, the orchestrator implements a "Sliding Relevance Window."

- **[3_MCP-TAS-049] Trigger Thresholds**:
    - **Warning**: At 600k tokens, the system flags the task for "Context Compression."
    - **Action**: At 800k tokens, the orchestrator triggers a **Gemini 3 Flash** "Compression Turn."
- **Compression Logic**:
    1.  Turns 1 through (N-10) are summarized into a structured Markdown "History Log."
    2.  The original tool observations (which are the largest part of the context) are discarded from the active window but remain in `state.sqlite`.
    3.  The active context is rebuilt using the summary + the last 10 raw turns.
- **[3_MCP-TAS-050] Spec Refresh Protocol**: To combat "Reasoning Decay," the system re-injects the full TAS and PRD text every 10 turns, ensuring the agent doesn't "forget" the high-level blueprints during long implementation cycles.

### 5.6 Memory Rewind & Consistency [3_MCP-TAS-039]
When a project is rolled back (Rewind), the memory layers must be synchronized to prevent "Future Leakage."

- **Relational Sync**: SQLite records with timestamps > Rewind Point are purged.
- **Vector Sync**: LanceDB entries are filtered by `timestamp` during retrieval to ensure the agent only sees information that was available at that point in the project's history.
- **Short-term Flush**: All active context windows are cleared, forcing the agent to rebuild its "Working Set" from the newly restored historical state.

### 5.7 Unknowns & Implementation Risks
- **[3_MCP-RISK-501] Semantic Drift**: Over time, summarized logs may lose the technical nuance (e.g., specific variable names) required for complex debugging. *Mitigation*: Always keep the last 5 terminal observations in raw, unsummarized form.
- **[3_MCP-RISK-502] Vector Retrieval Noise**: Semantic search might return irrelevant snippets from the PRD that distract the agent. *Mitigation*: Use metadata filtering (e.g., `epic_id`) to restrict search results to the current Epic's scope.
- **[3_MCP-RISK-503] Context Poisoning**: If an agent makes a "wrong" decision that is then summarized and committed to Long-term Memory, it may corrupt future tasks. *Mitigation*: Only "Approved" tasks and "Verified" architectural decisions are committed to the Vector DNA.
- **[3_MCP-UNKNOWN-501]**: Should we support "Shared Memory" across different projects built by the same user (e.g., a common UI library preference)?
- **[3_MCP-UNKNOWN-502]**: How do we handle "Conflicting Memory" (e.g., TAS says X, but a user directive mid-task says Y)? (Recommendation: User directives always take precedence in Short-term memory).

## 6. Security, Safety & Isolation

### 6.1 Sandbox Lifecycle
**[3_MCP-TAS-021]** Sandboxes (Docker/WebContainers) are ephemeral and managed strictly:
- **Provisioning**: Fresh sandbox per task.
- **Execution**: Max 300s per tool call. No network access by default.
- **Cleanup**: On success, the container is destroyed. On failure, it is "Suspended" to allow user inspection via `devs debug`.

### 6.2 Secret Masking (SecretMasker)
**[3_MCP-TAS-023]** The `SecretMasker` middleware intercepts all sandbox `stdout/stderr`.
- Uses regex and entropy detection to replace keys (AWS, Stripe, OpenAI) with `[REDACTED]`.
- Masking occurs *before* the data reaches the `agent_logs` or the LLM.

## 7. Implementation Edge Cases & Technical Risks

### 7.1 Technical Risks
| Risk ID | Description | Mitigation |
| :--- | :--- | :--- |
| **[3_MCP-RISK-301]** | **Sandbox Latency**: Docker startup per tool call is slow. | Implement a "Warm Pool" of containers or use WebContainers for lighter tasks. |
| **[3_MCP-RISK-302]** | **Dependency Deadlock**: Agent installs a package that conflicts with TAS. | Reviewer Agent must validate `package.json` diffs against TAS `allowed_libraries`. |
| **[3_MCP-RISK-303]** | **Context Drift**: Summaries lose critical technical nuance. | Always prioritize the TAS and raw Requirements in the pruning window. |

### 7.2 Implementation Requirements
- **ACID Persistence [3_MCP-REQ-SYS-002]**: Every state transition MUST be recorded in `state.sqlite` before the next tool call is executed.
- **Headless First [3_MCP-REQ-SYS-003]**: The OrchestratorServer MUST be accessible via standard IPC (Unix Sockets / Named Pipes) to ensure CLI and Extension parity.
- **Deterministic Hashing [3_MCP-REQ-SYS-004]**: The Entropy Detector MUST use a stable hashing algorithm for error outputs to ensure reliability across different environments.
