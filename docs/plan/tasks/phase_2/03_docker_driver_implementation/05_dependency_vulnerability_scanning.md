# Task: Dependency Vulnerability Scanning Pipeline Integration (Sub-Epic: 03_Docker Driver Implementation)

## Covered Requirements
- [8_RISKS-REQ-028], [8_RISKS-REQ-112]

## 1. Initial Test Written

- [ ] Create `packages/sandbox/src/docker/__tests__/DependencyAudit.spec.ts`.
- [ ] Write a test `DependencyAuditor.audit() returns AuditResult with zero vulnerabilities for a clean package.json` — mock the `npm audit --json` subprocess to return a JSON payload with `vulnerabilities: {}` and `metadata.vulnerabilities.high: 0, critical: 0`; assert `AuditResult.passed === true`.
- [ ] Write a test `DependencyAuditor.audit() returns AuditResult.passed=false when any "high" vulnerability is found` — mock `npm audit --json` to return a payload with `metadata.vulnerabilities.high: 1`; assert `AuditResult.passed === false` and `AuditResult.blocking` contains the vulnerability ID and package name.
- [ ] Write a test `DependencyAuditor.audit() returns AuditResult.passed=false when any "critical" vulnerability is found` — mock `npm audit --json` to return `metadata.vulnerabilities.critical: 1`; assert `AuditResult.passed === false`.
- [ ] Write a test `DependencyAuditor.audit() treats "moderate" and "low" as non-blocking` — mock `npm audit --json` with `moderate: 2, low: 3, high: 0, critical: 0`; assert `AuditResult.passed === true` and `AuditResult.warnings` contains two moderate entries.
- [ ] Write a test `DependencyAuditor.audit() throws DependencyAuditError when npm audit exits with code 2 (malformed JSON)` — mock the subprocess to exit 2 with non-JSON stdout; assert `DependencyAuditError` is thrown.
- [ ] Write a test `DependencyAuditor.audit() enforces package whitelist and blocks unlisted packages` — provide a `whitelist: ["lodash", "express"]` config; mock a lockfile containing `axios` (not in whitelist); assert `AuditResult.passed === false` with `AuditResult.blocking` describing the whitelist violation.
- [ ] Write a test `DependencyAuditor.audit() allows all packages when whitelist is empty (disabled)` — configure `whitelist: []`; assert whitelist check is skipped entirely.
- [ ] Write an integration test `DependencyAuditor.audit() runs real npm audit inside a Docker exec context` (tagged `@integration`) — provision a sandbox, write a minimal `package.json` with a known-vulnerable package version (e.g., `lodash@4.17.4`), run `npm install` via `DockerDriver.exec()`, then call `DependencyAuditor.audit()` against the workspace; assert `AuditResult.passed === false` and the lodash vulnerability appears in `blocking`.

## 2. Task Implementation

- [ ] Create `packages/sandbox/src/audit/DependencyAuditor.ts`:
  - Define `AuditConfig` interface:
    - `workspacePath: string` — absolute path to the workspace where `package.json` and `node_modules` reside.
    - `whitelist: string[]` — explicit list of allowed package names. Empty array = whitelist disabled.
    - `blockingSeverities: ('high' | 'critical')[]` — default `['high', 'critical']`.
  - Define `AuditVulnerability` interface: `{ id: string; package: string; severity: string; title: string; url: string }`.
  - Define `AuditResult` interface: `{ passed: boolean; blocking: AuditVulnerability[]; warnings: AuditVulnerability[]; rawOutput: string }`.
  - Implement `audit(config: AuditConfig): Promise<AuditResult>`:
    1. **Whitelist check**: Read `package-lock.json` (or `node_modules/.package-lock.json`) from `workspacePath`; extract all installed package names; for each not in `whitelist`, add a synthetic `AuditVulnerability` with `severity: 'whitelist-violation'` to `blocking`; skip if `whitelist` is empty.
    2. **Vulnerability scan**: Spawn `npm audit --json --prefix <workspacePath>` as a child process; capture stdout and stderr.
    3. **Parse output**: Parse stdout as JSON; iterate `vulnerabilities` map; for each entry whose severity is in `blockingSeverities`, push to `blocking`; others go to `warnings`.
    4. Return `AuditResult`; set `passed = blocking.length === 0`.
  - On subprocess exit code 2 or unparseable JSON, throw `DependencyAuditError` with the raw stderr attached.
- [ ] Define and export `DependencyAuditError` in `packages/sandbox/src/errors.ts`.
- [ ] Create `packages/sandbox/src/audit/PostInstallHook.ts`:
  - Export `runPostInstallAudit(exec: ExecFn, auditConfig: AuditConfig): Promise<void>`.
  - Calls `DependencyAuditor.audit(auditConfig)`.
  - If `AuditResult.passed === false`, throws `DependencyAuditError` with a summary of `blocking` entries — this causes the parent task to fail (requirement: [8_RISKS-REQ-028]).
  - Logs warnings (non-blocking) via the injected logger.
- [ ] Integrate `PostInstallHook` into `DockerDriver.exec()`: after any `exec` call where `command[0]` is `npm` and `command[1]` is `install` (or `ci`), automatically invoke `runPostInstallAudit` before resolving the `ExecResult` — inject the audit config via `DockerDriverConfig.auditConfig?: AuditConfig`.
- [ ] Add `auditConfig?: AuditConfig` to `DockerDriverConfig` in `DockerDriver.ts`; if omitted, auditing is skipped (warn in logger).
- [ ] Export `DependencyAuditor`, `PostInstallHook` from `packages/sandbox/src/index.ts`.

## 3. Code Review

- [ ] Verify the whitelist check reads the `package-lock.json` (not just `package.json`) to catch transitive dependencies added without explicit developer approval (requirement: [8_RISKS-REQ-112]).
- [ ] Verify that `audit()` does not spawn `npm audit` with `--fix`; the auditor is read-only and must never mutate the workspace.
- [ ] Verify `PostInstallHook` is invoked unconditionally after every `npm install` / `npm ci` exec — not only when a specific flag is set — except when `auditConfig` is explicitly `undefined` (which logs a warning).
- [ ] Verify `DependencyAuditError` carries the full list of `blocking` vulnerabilities as a structured `cause` property so the orchestrator can surface them in the UI without re-parsing logs.
- [ ] Confirm whitelist is case-insensitive in comparison to prevent typosquatting bypass (e.g., `Lodash` vs `lodash`) — requirement: [8_RISKS-REQ-112].
- [ ] Verify `spawn` uses `{ shell: false }` to prevent shell injection via crafted package names.

## 4. Run Automated Tests to Verify

- [ ] Run `pnpm --filter @devs/sandbox test` — all unit tests in `DependencyAudit.spec.ts` must pass.
- [ ] Run `pnpm --filter @devs/sandbox test:integration` — the real `npm audit` integration test must pass (requires network access in CI or a pre-populated audit DB).
- [ ] Run `pnpm --filter @devs/sandbox build` — TypeScript compiles cleanly.

## 5. Update Documentation

- [ ] Create `packages/sandbox/src/audit/DependencyAuditor.agent.md`:
  - **Intent**: Explain that `DependencyAuditor` enforces security policy by running `npm audit` after every package install and blocking the task pipeline on High/Critical findings (requirement [8_RISKS-REQ-028]).
  - **Architecture**: Document the two-phase check (whitelist validation → CVE audit), the `AuditResult` structure, and the integration point in `DockerDriver.exec()`.
  - **Agentic Hooks**: Describe that a `DependencyAuditError` must cause the implementing agent to either: (a) remove the offending package, (b) pin to a patched version, or (c) escalate to the user.
  - **Known Constraints**: `npm audit` requires internet access to the npm registry advisory database. In air-gapped environments, a pre-seeded local advisory DB must be configured.
- [ ] Update `packages/sandbox/README.md` with a "Dependency Auditing" section documenting how to configure the whitelist and how failures surface in task output.
- [ ] Add an entry to the project-level `SECURITY.md` (or create if absent) documenting the supply chain protection policy: whitelist strategy, audit timing, and escalation path for vulnerabilities (requirement: [8_RISKS-REQ-112]).

## 6. Automated Verification

- [ ] Run `pnpm --filter @devs/sandbox test --reporter=json | jq '[.testResults[].assertionResults[] | select(.status=="failed")] | length'` and assert output is `0`.
- [ ] Smoke test: run `node -e "const { DependencyAuditor } = require('./dist'); if(typeof DependencyAuditor !== 'function') process.exit(1);"` from `packages/sandbox/` after `pnpm build` — exit 0 confirms the class is correctly exported.
- [ ] CI enforcement: add a required step `pnpm --filter @devs/sandbox test -- --testPathPattern=DependencyAudit` to the Pull Request check workflow; assert exit code 0.
