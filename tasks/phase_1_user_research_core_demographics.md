# Tasks for User Research Core & Demographics (Phase: phase_1.md)

## Covered Requirements
- [REQ-UR-CORE], [REQ-UR-001], [REQ-UR-002], [REQ-UR-003], [REQ-UR-004], [REQ-UR-005]

### Task Checklist
- [ ] **Subtask 1: Define User Persona and Demographic Schema**: Define a TypeScript interface in `src/core/research/types.ts` that includes a `UserPersona` object. This object must contain fields for `id` (UUID), `role` (e.g., Maker, Architect), `demographics` (age: number, location: string, education: string), `goals` (string[]), `frustrations` (string[]), and `techSavviness` (enum: BEGINNER, INTERMEDIATE, EXPERT). This ensures standardized persona modeling across all agentic research outputs.
- [ ] **Subtask 2: Initialize Persona Data Files**: Create a directory `input/personas/` and populate it with JSON files for the primary personas: `maker.json`, `architect.json`, `domain_expert.json`, and `ai_developer.json`. These files must be populated with data synthesized from the `research/user_research.md` report, specifically linking personas to the core project needs.
- [ ] **Subtask 3: Design Decision Monitoring Protocol**: Define a `DecisionLog` interface in `src/core/logging/types.ts` that captures `timestamp` (ISO-8601), `agentId` (string), `decisionType` (e.g., ARCHITECTURAL_CHOICE, REQ_APPROVAL), `rationale` (markdown string explaining WHY), and `context` (snapshot of the system state during decision). This protocol is the technical backbone of the "Glass-Box" architecture.
- [ ] **Subtask 4: Implement Decision Logging Service**: Develop a `DecisionLogger` class in `src/core/logging/DecisionLogger.ts` that persists agent decisions to a `.devs/decision_log.jsonl` file. The class should expose an `async logDecision(decision: DecisionLog): Promise<void>` method. Implement file appending with atomic write guarantees to prevent corruption.
- [ ] **Subtask 5: Develop User Intervention Hook**: Implement an `awaitUserApproval()` utility in `src/core/interaction/UserGate.ts`. This utility should write a `PENDING_APPROVAL` status to the project state and halt the execution loop of the caller agent using a Promise-based wait mechanism that is resolved only when a user provides feedback via CLI or MCP.
- [ ] **Subtask 6: Establish Base TDD Workflow Configuration**: Configure a baseline testing environment using Vitest. Create a `vitest.config.ts` in the root directory and set up a `tests/baseline/` directory. Ensure the configuration supports TypeScript and can be easily triggered by agentic shell commands.
- [ ] **Subtask 7: Implement Mandatory TDD Cycle Enforcement**: Create a specialized agent tool `validate-tdd-step` in `src/tools/tdd_validator.ts`. This tool must check the current git diff or a task-specific staging area to verify that a failing test file was created and executed *before* any implementation code was added to the workspace for the current requirement ID.
- [ ] **Subtask8: Implement Empirical Verification Runner**: Create a tool `verify-implementation` that programmatically executes the relevant test suites for a given task. It must capture stdout/stderr, parse Vitest's JSON output, and return a structured report containing `status` (PASS/FAIL), `passingCount`, `failingCount`, and `diagnostics` (relevant error messages and stack traces).
- [ ] **Subtask 9: Create Markdown Templates for Authoritative Reports**: Design a set of Markdown templates in `src/core/research/templates/` (e.g., `research_report.md.hbs`). The templates must use a dry, authoritative tone and include placeholders for Mermaid.js diagrams to visualize technology landscapes and competitive positioning.
- [ ] **Subtask 10: Implement Report Assembly Engine**: Build a `ReportGenerator` service in `src/core/research/ReportGenerator.ts`. This service should ingest raw persona and research data and use the templates defined in Subtask 9 to output finalized reports to the `research/` directory, ensuring strict adherence to the "Authoritative" formatting constraints.
- [ ] **Subtask 11: Implement Architectural Review 'Gate'**: Add a `status` field to the project state machine (e.g., `src/core/state/ProjectState.ts`) for high-level documents (PRD, TAS). Implement logic that explicitly blocks the system from moving to the `DEVELOPMENT` phase if the `TAS_STATUS` is not `APPROVED`.
- [ ] **Subtask 12: Develop Approval Interface Logic**: Implement the backend logic for a `devs approve <doc_name>` command. This logic must update the project state to `APPROVED`, record a `DecisionLog` entry indicating user approval, and trigger a state-change notification that the next phase can begin.

### Testing & Verification
- [ ] **Unit Tests for Personas**: Create `tests/core/research/persona.test.ts` to verify that the `UserPersona` schema correctly validates input data and that all JSON persona files match the schema.
- [ ] **Decision Log Integration Test**: Create `tests/core/logging/decision_logger.test.ts` that simulates multiple agents logging decisions in parallel and verifies that the `.jsonl` output is valid, ordered, and contains all required metadata.
- [ ] **TDD Cycle Validation Test**: Create an integration test `tests/system/tdd_enforcement.test.ts` where a mock agent attempt to "implement" a feature without a test is rejected by the `validate-tdd-step` tool, and a subsequent attempt with a failing test is accepted.
- [ ] **Review Gate State Machine Test**: Create `tests/core/state/review_gate.test.ts` to verify that transition to `DEVELOPMENT` is logically impossible unless all architectural documents have been marked as `APPROVED`.
- [ ] **Report Formatting Verification**: Execute the `ReportGenerator` and use a regex-based validation test to ensure the output Markdown contains no "flowery" adjectives (e.g., "amazing", "incredible") and correctly formats Mermaid diagrams.
