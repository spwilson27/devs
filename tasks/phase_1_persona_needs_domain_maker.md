# Tasks for Persona Needs: Domain & Maker (Phase: phase_1.md)

## Covered Requirements
- [REQ-NEED-DOMAIN-01], [REQ-NEED-DOMAIN-02], [REQ-NEED-DOMAIN-03], [REQ-NEED-MAKER-01], [REQ-NEED-MAKER-02], [REQ-NEED-MAKER-03]

### Task Checklist

- [ ] **Subtask 1: Implement Zero-Config Project Scaffolder (REQ-NEED-MAKER-01)**: Develop a `ScaffolderAgent` within the `@devs/core` package responsible for initializing the project directory structure. The agent must parse the PRD and TAS to create a standardized layout including `.devs/` (internal state), `.agent/` (agent-oriented docs), `src/`, `tests/`, `docs/`, and `mcp-server/`. Ensure it populates boilerplate files like `.gitignore`, `package.json` with version-locked dependencies, and a `README.md` derived from the project brief.
- [ ] **Subtask 2: Develop Non-Technical Progress Summarizer (REQ-NEED-MAKER-02)**: Create a `ProgressSummarizerAgent` that translates the technical state of the Task DAG and Epic files into clear, non-technical Markdown summaries. This agent must query the SQLite `epics` and `tasks` tables to determine completion percentages and current blockers, then generate a "Project Health" report. The output should be exposed via a new `devs status --summary` CLI command and streamed to the VSCode dashboard.
- [ ] **Subtask 3: Build Phase-Specific Token & Cost Estimator (REQ-NEED-MAKER-03)**: Implement a `CostEstimator` middleware in the `OrchestrationGraph` that intercepts all LLM API calls. It must log exact input/output token counts to the `agent_logs` table and calculate real-time costs based on the model's pricing tier (e.g., Gemini 2.0 Pro). Provide a reporting utility that aggregates these costs per Epic, allowing the "Maker" to see the financial impact of each development phase.
- [ ] **Subtask 4: Enhance Research Agent for High-Fidelity Rationale Reports (REQ-NEED-DOMAIN-01)**: Update the `ResearchAgent` system prompt to mandate the inclusion of a "Decision Rationale" (The "Why") for every technological choice. The agent must generate high-fidelity Markdown reports in `docs/research/` that include Mermaid.js diagrams for architectural visualisations and explicit comparisons against alternative technologies identified during the research phase.
- [ ] **Subtask 5: Implement Agentic Performance Profiling via MCP (REQ-NEED-DOMAIN-02)**: Develop a `ProfilerAgent` that utilizes the Project MCP Server's `run_profiler` tool. This agent must be able to trigger CPU and memory profiling within the `devs-sandbox`, ingest the resulting trace files (e.g., Flamegraphs, heap snapshots), and generate a natural-language explanation of performance bottlenecks. The explanation must be targeted at domain experts who may be unfamiliar with the specific implementation details.
- [ ] **Subtask 6: Build Interactive Architect Q&A Interface (REQ-NEED-DOMAIN-03)**: Implement a dedicated `Q&A` node in the LangGraph orchestrator that allows users to query the `ArchitectAgent`. The agent must be initialized with the full context of `specs/1_prd.md` and `specs/2_tas.md` stored in the LanceDB vector memory. It should provide detailed answers regarding architectural trade-offs, security model enforcement, and design patterns used throughout the project.

### Testing & Verification

- [ ] **Scaffolding Integrity Check**: Run the `ScaffolderAgent` on a fresh directory and verify that all directories defined in [TAS-040] exist and that `package.json` contains the correct `devs` metadata block.
- [ ] **Progress Summary Accuracy**: Update a task in the SQLite database to `SUCCESS` and verify that the `ProgressSummarizerAgent` correctly reflects the change in its non-technical summary output.
- [ ] **Token Usage & Cost Validation**: Execute a multi-turn agent task and assert that the `agent_logs` table contains non-zero `token_usage` values and that the aggregated cost report matches the expected value based on current Gemini pricing.
- [ ] **Research Rationale Audit**: Inspect a generated `tech_landscape.md` report and verify it contains at least three Mermaid.js diagrams and a "Rationale" section for each core library choice (e.g., LangGraph.js, SQLite).
- [ ] **Sandbox Profiling Loop**: Inject a `while(true)` loop or a heavy computational task into a sandbox file. Use the `ProfilerAgent` to identify the bottleneck via MCP and verify the generated explanation correctly points to the offending line of code.
- [ ] **Architect Q&A Grounding**: Ask the `ArchitectAgent` a specific "Why" question (e.g., "Why are we using SQLite for state instead of Redis?") and verify the response is grounded in the justifications provided in `specs/2_tas.md`.
