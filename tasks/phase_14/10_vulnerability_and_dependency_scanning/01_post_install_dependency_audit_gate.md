# Task: Implement Post-Install Dependency Audit Gate (Sub-Epic: 10_Vulnerability and Dependency Scanning)

## Covered Requirements
- [1_PRD-REQ-SEC-007], [5_SECURITY_DESIGN-REQ-SEC-SD-056]

## 1. Initial Test Written
- [ ] In `packages/orchestrator/src/security/__tests__/auditGate.test.ts`, write unit tests for a new `AuditGate` class:
  - Test `runAudit(projectPath: string, packageManager: 'npm' | 'pip' | 'cargo')` returns a structured `AuditReport` object with fields: `{ vulnerabilities: AuditVulnerability[], hasCritical: boolean, hasHigh: boolean, rawOutput: string }`.
  - Test that when `npm audit --json` exits with code 0 and returns no vulnerabilities, `hasCritical` and `hasHigh` are both `false`.
  - Test that when `npm audit --json` returns a JSON payload containing a vulnerability with `severity: 'critical'`, `hasCritical` is `true`.
  - Test that when `npm audit --json` returns a JSON payload containing a vulnerability with `severity: 'high'`, `hasHigh` is `true`.
  - Test that when `pip-audit --format=json` is called for a Python project, the output is correctly parsed into the same `AuditReport` structure.
  - Test that when `cargo audit --json` is called for a Rust project, the output is correctly parsed.
  - Test that the function correctly detects the package manager from the presence of `package.json`, `requirements.txt`/`pyproject.toml`, or `Cargo.toml` in the `projectPath` when the `packageManager` parameter is set to `'auto'`.
  - Write an integration test using a temporary directory with a mock `package.json` that stubs the `npm audit` child process and validates the full parse pipeline.

## 2. Task Implementation
- [ ] Create `packages/orchestrator/src/security/auditGate.ts`:
  - Define the `AuditVulnerability` interface: `{ id: string; severity: 'info' | 'low' | 'moderate' | 'high' | 'critical'; packageName: string; title: string; url?: string; }`.
  - Define the `AuditReport` interface: `{ vulnerabilities: AuditVulnerability[]; hasCritical: boolean; hasHigh: boolean; packageManager: string; rawOutput: string; timestamp: string; }`.
  - Implement `async function runAudit(projectPath: string, packageManager?: PackageManagerType): Promise<AuditReport>`.
  - Auto-detect package manager by checking for `package.json`, `requirements.txt`, `pyproject.toml`, and `Cargo.toml` in that order when `packageManager` is not provided.
  - For **npm**: spawn `npm audit --json --prefix <projectPath>` via Node.js `child_process.spawn`. Parse the JSON output from stdout. Map `advisories[*].severity` to `AuditVulnerability[]`.
  - For **pip**: spawn `pip-audit --format=json --requirement <projectPath>/requirements.txt` or `pip-audit --format=json` if `pyproject.toml` is present. Parse the JSON output.
  - For **cargo**: spawn `cargo audit --json` in `projectPath`. Parse the JSON output from `vulnerabilities.list`.
  - Ensure the function captures both stdout and stderr. If the process fails to spawn (command not found), throw an `AuditToolNotFoundError` with a descriptive message that includes the package manager name and install instructions.
  - Set `hasCritical = vulnerabilities.some(v => v.severity === 'critical')` and `hasHigh = vulnerabilities.some(v => v.severity === 'high')`.
  - Export a singleton `auditGate` instance for use by the orchestrator pipeline.
- [ ] Add `pip-audit` as a Python dev dependency in `scripts/requirements-dev.txt` (if it exists) or document it as a prerequisite.
- [ ] Integrate `auditGate.runAudit()` into `packages/orchestrator/src/pipeline/dependencyInstallStep.ts` (or equivalent) to be called immediately after every package installation command completes, passing the sandbox project path.

## 3. Code Review
- [ ] Verify that `runAudit` does not throw unhandled exceptions on malformed JSON output from the audit tool; instead, it should log the raw output and return a report indicating `hasCritical: false, hasHigh: false` with an error note in `rawOutput`.
- [ ] Confirm that child processes are spawned with a timeout (e.g., 120 seconds) and are killed cleanly on timeout using `AbortController` / `AbortSignal`.
- [ ] Verify no secrets or environment variables from the host leak into the audit process's environment — use a minimal `env` object containing only `PATH` and `HOME`.
- [ ] Ensure the `AuditGate` class and all interfaces are exported from `packages/orchestrator/src/security/index.ts`.
- [ ] Confirm test coverage ≥ 90% for `auditGate.ts` as reported by the project's coverage tool.

## 4. Run Automated Tests to Verify
- [ ] Run `pnpm --filter orchestrator test --testPathPattern=auditGate` and confirm all tests pass.
- [ ] Run `pnpm --filter orchestrator test --coverage` and confirm `auditGate.ts` line coverage ≥ 90%.
- [ ] Run the full orchestrator test suite `pnpm --filter orchestrator test` and confirm no regressions.

## 5. Update Documentation
- [ ] Add a section to `docs/security.md` (or create it if absent) titled **"Post-Install Dependency Audit Gate"** describing: which package managers are supported, the auto-detection logic, and how the audit is triggered.
- [ ] Update the `packages/orchestrator/README.md` to list the `AuditGate` in the "Security" section of the architecture overview.
- [ ] Add an inline comment above the `runAudit` function: `// [1_PRD-REQ-SEC-007] [5_SECURITY_DESIGN-REQ-SEC-SD-056]: Automated audit gate runs after every dependency install.`

## 6. Automated Verification
- [ ] Run `pnpm --filter orchestrator test --testPathPattern=auditGate --passWithNoTests=false` and assert exit code is `0`.
- [ ] Run `grep -r "1_PRD-REQ-SEC-007" packages/orchestrator/src/security/auditGate.ts` and confirm the requirement tag appears in source.
- [ ] Run `grep -r "5_SECURITY_DESIGN-REQ-SEC-SD-056" packages/orchestrator/src/security/auditGate.ts` and confirm the requirement tag appears in source.
