# Task: Implement Package Manager Allow-list Enforcement (Sub-Epic: 10_Vulnerability and Dependency Scanning)

## Covered Requirements
- [1_PRD-REQ-SEC-008]

## 1. Initial Test Written
- [ ] In `packages/orchestrator/src/security/__tests__/allowlist.test.ts`, write unit tests for a new `PackageAllowlist` class:
  - Test that `isAllowed(packageName: string, registry: string)` returns `true` for a package explicitly in the allow-list.
  - Test that `isAllowed` returns `false` for a package not on the allow-list when the policy is `strict`.
  - Test that `isAllowed` returns `true` for any package when the policy is `permissive` (default during initial dev), but logs a warning.
  - Test that `addToAllowlist(packageName: string, approvedBy: string, reason: string)` correctly persists the entry to the allow-list store and requires a non-empty `approvedBy` and `reason`.
  - Test that `validateInstallCommand(command: string, args: string[])` throws `AllowlistViolationError` when a `npm install <pkg>` command includes a package not on the allow-list in `strict` mode.
  - Test that `validateInstallCommand` passes when all packages in the command are on the allow-list.
  - Test that `validateInstallCommand` correctly parses `npm install`, `pip install`, `cargo add`, and `pnpm add` command formats to extract package names.
  - Test that the allow-list supports wildcard entries (e.g., `@types/*` allows all `@types/` scoped packages).
  - Test that `loadAllowlist(configPath: string)` reads a JSON/YAML config file at `configPath` and populates the in-memory allow-list, throwing a descriptive error if the file is malformed.
  - Test that the allow-list config is validated against a JSON schema on load, rejecting unknown fields.

## 2. Task Implementation
- [ ] Create `packages/orchestrator/src/security/allowlist.ts`:
  - Define `AllowlistEntry` interface: `{ packageName: string; registry: string; approvedBy: string; reason: string; approvedAt: string; }`.
  - Define `AllowlistConfig` interface: `{ policy: 'strict' | 'permissive'; registries: string[]; packages: AllowlistEntry[]; }`.
  - Implement `class PackageAllowlist` with:
    - `loadAllowlist(configPath: string): Promise<void>` — reads `<configPath>/.devs/allowlist.json`, validates against the JSON schema.
    - `isAllowed(packageName: string, registry?: string): boolean` — checks exact match and wildcard match (e.g., `@types/*`).
    - `addToAllowlist(packageName: string, approvedBy: string, reason: string): Promise<void>` — appends to `.devs/allowlist.json`, setting `approvedAt` to the current ISO timestamp.
    - `validateInstallCommand(packageManager: string, args: string[]): void` — extracts package names from the args array (handling flags like `--save-dev`, `-D`, `--dev`), then calls `isAllowed` for each. Throws `AllowlistViolationError` (extending `Error`) listing all disallowed packages.
  - Create `packages/orchestrator/src/security/allowlistSchema.json` — JSON Schema for the `AllowlistConfig`.
  - Create a default `templates/allowlist.json` in the orchestrator package with sensible defaults for common package registries (`registry.npmjs.org`, `pypi.org`, `crates.io`).
- [ ] Create `packages/orchestrator/src/errors/AllowlistViolationError.ts` with `class AllowlistViolationError extends Error` containing a `disallowedPackages: string[]` property.
- [ ] Integrate `PackageAllowlist.validateInstallCommand()` into the sandbox execution layer in `packages/orchestrator/src/sandbox/commandRunner.ts` (or equivalent). Call it before executing any package-install-type shell command. If an `AllowlistViolationError` is thrown, abort the task and surface the error to the orchestrator pipeline.
- [ ] Expose a `devs allowlist add <package> --reason "<reason>"` CLI subcommand in `packages/cli/src/commands/allowlist.ts` that calls `PackageAllowlist.addToAllowlist()`.

## 3. Code Review
- [ ] Confirm that `validateInstallCommand` is called before executing commands, not after (pre-execution enforcement, not audit-only).
- [ ] Verify wildcard matching uses a safe comparison that cannot be exploited (e.g., no `eval`, no `RegExp` from user input — use simple prefix matching for `*` patterns).
- [ ] Confirm that `AllowlistViolationError` surfaces a human-readable message listing all blocked packages and instructions to add them (`devs allowlist add <pkg> --reason "..."`).
- [ ] Verify the allow-list config file path resolves relative to the project root, not the orchestrator's CWD, preventing path traversal issues.
- [ ] Ensure the `addToAllowlist` function is atomic (write to a temp file, then rename) to prevent corruption on concurrent writes.
- [ ] Confirm all new exports are present in `packages/orchestrator/src/security/index.ts`.

## 4. Run Automated Tests to Verify
- [ ] Run `pnpm --filter orchestrator test --testPathPattern=allowlist` and confirm all tests pass with zero failures.
- [ ] Run `pnpm --filter cli test --testPathPattern=allowlist` and confirm the CLI command tests pass.
- [ ] Run the full test suite `pnpm test` and confirm no regressions.

## 5. Update Documentation
- [ ] Create `docs/allowlist.md` describing: the allow-list policy modes (`strict` vs `permissive`), the `allowlist.json` schema, how to add packages via CLI (`devs allowlist add`), and how to configure registries.
- [ ] Update `docs/security.md` to reference the allow-list feature.
- [ ] Add inline comment above `validateInstallCommand`: `// [1_PRD-REQ-SEC-008]: Enforces explicit package allow-list before any dependency install.`
- [ ] Add the `allowlist` command to the `packages/cli/README.md` command reference table.

## 6. Automated Verification
- [ ] Run `pnpm --filter orchestrator test --testPathPattern=allowlist --passWithNoTests=false` and assert exit code is `0`.
- [ ] Run `grep -r "1_PRD-REQ-SEC-008" packages/orchestrator/src/security/allowlist.ts` and confirm the requirement tag is present.
- [ ] Run `node -e "const s = require('./packages/orchestrator/src/security/allowlistSchema.json'); console.log(s.type)"` and confirm it outputs `object` (schema is valid JSON).
