---
package: "@devs/core"
module_group: "recovery"
type: directory-overview
status: active
created: 2026-02-21
requirements: ["1_PRD-REQ-REL-003", "1_PRD-REQ-SYS-002", "1_PRD-REQ-MET-014", "1_PRD-REQ-CON-002"]
---

# recovery/ — Crash Recovery Engine

## Purpose

This directory implements the crash recovery engine for the devs orchestration
pipeline. When a process is interrupted (SIGKILL, OOM, power loss, etc.), the
WAL-backed SQLite database preserves all committed LangGraph checkpoints.
`RecoveryManager` detects those checkpoints and prepares a `RunnableConfig`
that lets a new process resume from the exact node and state the graph was in
before the interruption — with zero data loss.

## Modules

| Module            | Description                                                                              |
|-------------------|------------------------------------------------------------------------------------------|
| `RecoveryManager` | Bridges `SqliteSaver` (checkpoint layer) and `StateRepository` (business layer) to detect, prepare, and audit crash recovery |

## Design Constraints

- `RecoveryManager` operates on the **same** `better-sqlite3` `Database` instance
  as the rest of the core persistence layer. It creates its own `SqliteSaver`
  instance internally to query the `checkpoints` table.
- The `thread_id` in the `checkpoints` table equals the project UUID
  (`OrchestrationGraph.configForProject(projectId)`). All recovery queries are
  scoped to a single `thread_id`.
- `markInProgressTasksAsResumed()` works on the **integer** project id from the
  `projects` SQLite table — this is the numeric FK hierarchy, distinct from the
  UUID used in LangGraph. Callers must pass the correct ID type.
- `RecoveryManager` does NOT own the database connection. The caller manages the
  connection lifecycle (open / close).
- The `checkpoints` table is created idempotently by `SqliteSaver`'s constructor.
  `RecoveryManager` relies on this — no explicit DDL is run by `RecoveryManager`.
